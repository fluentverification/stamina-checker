<!DOCTYPE html>
<html>
<head>
	<title>Home - STAMINA Model Checker</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="styles.css">
	<link rel="icon" type="image/x-icon" href="images/favicon.svg">
	<script type="text/javascript" src="scripts/scripts.js"></script>
</head>
<body>
<!-- Navigation Bar -->
<ul class="navbar" id="navbar">
	<li><a class="stamina-name" id="stamina" href="index.html">STAMINA</a></li>
	<li><a class="openbutton" id="openbutton" onclick="openNav()">&#9776;</a></li>
	<li><a class="closebutton" id="closebutton" onclick="closeNav()">&times;</a></li>
	<li><a class="active" id="active" href="index.html">Home</a></li>
	<li><a class="navbutton" href="about.html">About</a></li>
	<li>
		<a href="get.html" class="navbutton" class="navbutton">Get</a>
		<!--<div class="dropdown-content">
			<a href="download.html">Download</a>
			<a href="https://github.com/fluentverification/stamina">Source Code</a>
		</div>-->
	</li>
	<li><a class="navbutton" href="documentation.html">Documentation</a></li>
	<li><a class="navbutton" href="benchmarks.html">Benchmarks</a></li>
	<li class="right"><a class="fluent" href="https://fluentverification.github.io">FLUENT Verification</a></li>
</ul>
<div class="top-buffer" id="top-buffer"><br></div>
<div class="banner">
	<h1>STAMINA</h1>
	<h2>
		A model-truncation tool that can analyze infinite-sized models.
	</h2>
	<a class="button" href="https://github.com/fluentverification/stamina">&#129095; Download Latest Release (2.1)</a>
	<a class="button" href="https://github.com/fluentverification/stamina">&#129957; Get Source Code</a>
</div>
<div class="content">
<!-- CONTENT -->
	<img src="images/staminaGraphic.svg" class="graphic">
	<h1>STAMINA: STochastic Approximate Model-checker for INfinite-state Analysis</h1>
	<p>STAMINA is an infinite state-space model truncation tool compatible with both <a href="#">PRISM</a> and <a href="#">STORM</a>. STAMINA is a tool within the <a href="#">FLUENT</a> toolchain. It deploys a state truncation-based approach, estimating path probabilities of reaching each state on-the-fly and terminates exploration of a path when the cumulative estimated probability along such a path drops below a predefined threshold. Each terminated path is routed to an absorbing state, in order to estimate the error probability in subsequent CTMC analysis.</p>
	<p>After all paths have been explored or truncated, transient Markov chain analysis is applied to determine the probability of a transient property of interest specified using Continuous Stochastic Logic (CSL). The calculated probability forms a lower bound on the probability, while the upper bound also includes the probability of the absorbing state. The actual probability of the CSL property is guaranteed to be within this range. If the probability bound is still too large compared to a user-provided probability precision value (default is 10<sup>-3</sup>), the PRISM version of STAMINA employs a property property-guided refinement technique to expand the state space to tighten the reported probability range incrementally.</p>
	<h2>The STAMINA Algorithm(s)</h2>
	<p>
		STAMINA makes use of multiple variations on a smart breadth-first search algorithm to estimate reachability probability on-the-fly. It does not explore paths whose reachability is below a certain user-defined threshold, &kappa;, which automatically decrements until the probability window is within a certain bound. Currently there are several variations on the STAMINA algorithm.
	</p>
	<h3>The STAMINA 1.0 Algorithm</h3>
	<p>
		STAMINA 1.0 was originally developed by several students under Dr Zhen Zhang, including [TODO]. The basic idea of the algorithm is that for each iteration of &kappa;, states are only explored if an estimated reachability value (based somewhat on the embedded DTMC). While the probability estimate window is too wide, &kappa; is progressively reduced and state exploration is continued. The problem with this was that as &kappa; was reduced, we had no way to continue exploring states we had already truncated in previous iterations.
	</p>
	<h3>The STAMINA 2.0/2.1 Algorithm</h3>
	<p>
		STAMINA 2.0 is the na&#239;ve approach to fixing the problem presented in STAMINA 1.0: simply re-explore the entire state space with the current value of &kappa;. The logic regarding performance is that model checking with PRISM was the bottleneck in the algorithm, whereas the state exploration was extremely fast, likely because the PRISM model checker spent far more time checking rather than building the model. However, when this was implemented in C++ to interface with the STORM model checker, precisely the opposite was found: that the model building and truncating were the bottleneck.
	</p>
	<h4>Dynamic Programming Improvements (STAMINA 2.5)</h4>
	<p>
		In order to make STAMINA/STORM faster, in addition to memory pooling and decreased use of <div class="inline-code">std::unordered_map</div> and <div class="inline-code">std::unordered_set</div> (which after much testing, were determined to be far slower than the Java equivalent), certain dynamic programming improvements were devised to the STAMINA 2.0 algorithm. Please note that these are implemented exclusively in the STORM integration. The improvements simply keep track of the reachability that would have been lost in previous iterations and enqueue "lost" states to be explored alongside terminal states of the last iteration, rather than either the initial state (STAMINA 2.0) or the previous terminal states (STAMINA 1.0).
	</p>
	<h3>The STAMINA 3.0 Algorithm</h3>
	<p>
		STAMINA 3.0 (not yet released) reduces complexity of the algorithm further. Rather than using &kappa; and r<sub>&kappa;</sub> to conditionally truncate states, all states, as they are explored, are inserted into a priority queue on the value &pi;[s], the estimated reachability of that state. States are explored in order of their estimated reachability. If a current state transitions into a state that is already enqueued, we do not force the queue to re-order until that state is dequeued and explored.
	</p>
	<h3>The STAMINA Heuristic Algorithm</h3>
	<p>
		The STAMINA Heuristic algorithm has not yet been implemented nor tested but would provide an alternate means of termination rather than estimated terminal reachability.
	</p>
</div>
<!-- Footer -->
<div class="footer">
	<div class="footer-links">
		<table style="width:80%">
			<tr>
				<th>STAMINA Information</th>
				<th>FLUENT Information</th>
				<th>Papers and Research</th>
			</tr>
			<tr>
				<td><a href="#">STAMINA/STORM</a></td>
				<td><a href="index.html">State-space truncation (STAMINA)</a></td>
				<td><a href="#">Google Scholar</a></td>
			</tr>
			<tr>
				<td><a href="#">STAMINA/PRISM</a></td>
				<td><a href="#">Property-Directed Reachability</a></td>
			</tr>
			<tr>
				<td><a href="#">Contact Developers</a></td>
				<td><a href="#">Counterexample Generation</a></td>
			</tr>
			<tr>
				<td></td>
				<td><a href="#">Fluent Website</a></td>
			</tr>
			<tr>
				<td></td>
				<td><a href="#">Contact Fluent</a></td>
			</tr>
		</table>
	</div>
	<div style="padding-top: 30px;" >
		STAMINA is developed at <a href="https://www.usu.edu/">Utah State University</a> and is part of the tools developed by the FLUENT Team. The STAMINA tool is licensed under the MIT license, and the model checkers it integrates with, STORM and PRISM, are under the GPL 3.0 and 2.0 licenses respectively.
	</div>
	<div style="padding-top: 10px; font-size: 8pt;" >
		This website is designed and developed by hand by Josh Jeppson. The content and design of this website is licensed under the CC-BY-SA license.
	</div>
</div>
</body>
